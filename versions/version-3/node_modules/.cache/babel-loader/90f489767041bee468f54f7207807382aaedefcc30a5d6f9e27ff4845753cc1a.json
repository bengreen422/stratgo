{"ast":null,"code":"var _jsxFileName = \"/Users/ben/StratGO/frontend/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\n\n// Letter frequencies for board generation\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst letterFrequencies = [{\n  letter: 'E',\n  freq: 12.7\n}, {\n  letter: 'T',\n  freq: 9.1\n}, {\n  letter: 'A',\n  freq: 8.2\n}, {\n  letter: 'O',\n  freq: 7.5\n}, {\n  letter: 'I',\n  freq: 7.0\n}, {\n  letter: 'N',\n  freq: 6.7\n}, {\n  letter: 'S',\n  freq: 6.3\n}, {\n  letter: 'H',\n  freq: 6.1\n}, {\n  letter: 'R',\n  freq: 6.0\n}, {\n  letter: 'D',\n  freq: 4.3\n}, {\n  letter: 'L',\n  freq: 4.0\n}, {\n  letter: 'C',\n  freq: 2.8\n}, {\n  letter: 'U',\n  freq: 2.8\n}, {\n  letter: 'M',\n  freq: 2.4\n}, {\n  letter: 'W',\n  freq: 2.4\n}, {\n  letter: 'F',\n  freq: 2.2\n}, {\n  letter: 'G',\n  freq: 2.0\n}, {\n  letter: 'Y',\n  freq: 2.0\n}, {\n  letter: 'P',\n  freq: 1.9\n}, {\n  letter: 'B',\n  freq: 1.5\n}, {\n  letter: 'V',\n  freq: 1.0\n}, {\n  letter: 'K',\n  freq: 0.8\n}, {\n  letter: 'J',\n  freq: 0.15\n}, {\n  letter: 'X',\n  freq: 0.15\n}, {\n  letter: 'Q',\n  freq: 0.10\n}, {\n  letter: 'Z',\n  freq: 0.07\n}];\nconst weightedLetters = [];\nletterFrequencies.forEach(({\n  letter,\n  freq\n}) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({\n    length: size\n  }, (_, i) => Array.from({\n    length: size\n  }, (_, j) => getRandomLetter()));\n}\nconst scoreTable = {\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 6,\n  6: 8,\n  7: 11,\n  8: 14,\n  9: 19,\n  10: 24\n};\nfunction getScore(word) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\nfunction areAdjacent(a, b) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected) {\n  if (selected.length <= 1) return true;\n  const visited = new Set();\n  function dfs(cell) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\n\nfunction createBoardWithOwnership(letters) {\n  return letters.map(row => row.map(letter => ({\n    letter,\n    owner: null,\n    captured: false,\n    pulse: false\n  })));\n}\n// Figma UI update END\n\nfunction App() {\n  _s();\n  const [board, setBoard] = useState([]);\n  const [turn, setTurn] = useState('Player 1');\n  const [selected, setSelected] = useState([]);\n  const [error, setError] = useState(null);\n  const [moves, setMoves] = useState([]);\n  const [scores, setScores] = useState({\n    'Player 1': 0,\n    'Player 2': 0\n  });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [dictionary, setDictionary] = useState(null);\n  const [passCount, setPassCount] = useState(0);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt').then(res => res.text()).then(text => {\n      const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n      setDictionary(new Set(words));\n    });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => {\n    var _board$i, _board$i$j;\n    return ((_board$i = board[i]) === null || _board$i === void 0 ? void 0 : (_board$i$j = _board$i[j]) === null || _board$i$j === void 0 ? void 0 : _board$i$j.letter) || '';\n  }).join('');\n\n  // Handle cell click\n  const handleCellClick = (i, j) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected;\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i, j, moves) => {\n    return board[i][j].owner !== null;\n  };\n\n  // --- Encirclement Logic Version 1 ---\n  // This is the preferred and tested encirclement logic as of [date].\n  // To roll back to this version, search for 'Encirclement Logic Version 1'.\n  // The logic allows capture even if there are unclaimed tiles adjacent, as long as those unclaimed tiles are also fully surrounded and cannot form a valid word.\n  // The previous logic is commented out below for easy rollback.\n  // --- END Encirclement Logic Version 1 ---\n  function findEncircledGroups(board, currentPlayer, dictionary) {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({\n      length: size\n    }, () => Array(size).fill(false));\n    const groups = [];\n    function isEdge(i, j) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI, startJ) {\n      const queue = [[startI, startJ]];\n      const group = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set();\n      while (queue.length) {\n        const [i, j] = queue.shift();\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n          const ni = i + di,\n            nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return {\n        group,\n        edgeTouches\n      };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const {\n            group,\n            edgeTouches\n          } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // --- BEGIN: Old logic for easy rollback ---\n          /*\n          // New encirclement logic: expand group to include any unclaimed tiles fully enclosed by the boundary. Only capture if no valid word can be formed from the unclaimed tiles inside the boundary.\n          // 1. Find all unclaimed tiles orthogonally connected to the group that are also fully enclosed (do not touch more than one edge or connect to outside)\n          const groupSet = new Set(group.map(([x, y]) => `${x},${y}`));\n          const enclosedUnclaimed: [number, number][] = [];\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (board[ni][nj].owner === null && !groupSet.has(`${ni},${nj}`)) {\n                // Check if this unclaimed tile is fully enclosed (BFS to see if it can reach the edge without passing through currentPlayer's tiles)\n                const queue: [number, number][] = [[ni, nj]];\n                const visitedUnclaimed = new Set([`${ni},${nj}`]);\n                let touchesEdge = false;\n                let escapes = false;\n                while (queue.length) {\n                  const [ui, uj] = queue.shift()!;\n                  if (isEdge(ui, uj)) touchesEdge = true;\n                  for (const [udi, udj] of [\n                    [-1, 0], [1, 0], [0, -1], [0, 1]\n                  ]) {\n                    const vi = ui + udi, vj = uj + udj;\n                    if (vi < 0 || vj < 0 || vi >= size || vj >= size) continue;\n                    if (board[vi][vj].owner === currentPlayer) continue; // blocked by current player's tile\n                    if (!visitedUnclaimed.has(`${vi},${vj}`) && board[vi][vj].owner === null) {\n                      visitedUnclaimed.add(`${vi},${vj}`);\n                      queue.push([vi, vj]);\n                    }\n                  }\n                }\n                if (!touchesEdge) {\n                  enclosedUnclaimed.push([ni, nj]);\n                  groupSet.add(`${ni},${nj}`);\n                }\n              }\n            }\n          }\n          // Now, group + enclosedUnclaimed is the full encircled area\n          const allEncircled = [...group, ...enclosedUnclaimed];\n          const groupLetters = allEncircled.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allEncircled);\n            groups.push(group);\n          }\n          */\n          // --- END: Old logic for easy rollback ---\n          // New logic: flood fill from group and all orthogonally adjacent unclaimed tiles. If the fill cannot reach the board edge without crossing currentPlayer's tiles, and no valid word can be formed from the unclaimed tiles, capture the group.\n          const floodVisited = Array.from({\n            length: size\n          }, () => Array(size).fill(false));\n          const queue = [...group];\n          group.forEach(([x, y]) => {\n            floodVisited[x][y] = true;\n          });\n          // Add all orthogonally adjacent unclaimed tiles to the queue\n          for (const [x, y] of group) {\n            for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n              const ni = x + di,\n                nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (!floodVisited[ni][nj] && board[ni][nj].owner === null) {\n                queue.push([ni, nj]);\n                floodVisited[ni][nj] = true;\n              }\n            }\n          }\n          let escapes = false;\n          let allFlood = [];\n          while (queue.length) {\n            const [cx, cy] = queue.shift();\n            allFlood.push([cx, cy]);\n            if (isEdge(cx, cy)) escapes = true;\n            for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n              const nx = cx + di,\n                ny = cy + dj;\n              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;\n              if (floodVisited[nx][ny]) continue;\n              if (board[nx][ny].owner === currentPlayer) continue; // blocked by current player's tile\n              floodVisited[nx][ny] = true;\n              queue.push([nx, ny]);\n            }\n          }\n          if (escapes) {\n            console.log('Flood fill escapes to edge, not encircled');\n            continue;\n          }\n          // Only capture if no valid word can be formed from the unclaimed tiles in the flood area\n          const groupLetters = allFlood.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allFlood);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({\n      ...cell\n    })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({\n        ...cell,\n        pulse: false\n      }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, {\n      player: turn,\n      word,\n      positions: [...selected],\n      score,\n      capturePoints: capturedCount\n    }]);\n    setScores(s => ({\n      ...s,\n      [turn]: s[turn] + score + capturedCount\n    }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n  };\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({\n      'Player 1': 0,\n      'Player 2': 0\n    });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i, j, moves) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Word Strategy Game (Local Two-Player)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 432,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Current Turn:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 433,\n        columnNumber: 12\n      }, this), \" \", turn]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"score-panel\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"player1\",\n        children: [\"Player 1: \", scores['Player 1']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 436,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"player2\",\n        children: [\"Player 2: \", scores['Player 2']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 435,\n      columnNumber: 7\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        background: '#eee',\n        padding: 20,\n        borderRadius: 8,\n        margin: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Game Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 442,\n        columnNumber: 11\n      }, this), winner === 'Draw' ? /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"It's a draw!\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 443,\n          columnNumber: 37\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 443,\n        columnNumber: 32\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: [winner, \" wins!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 443,\n          columnNumber: 80\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 443,\n        columnNumber: 75\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleRestart,\n        children: \"Restart Game\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 441,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'inline-block',\n        marginTop: 20\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'grid',\n          gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n          marginTop: 20,\n          border: '2px solid #333',\n          width: (board.length + 1) * 30,\n          position: 'relative'\n        },\n        children: [board[0] && board[0].map((_, j) => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            gridRow: 1,\n            gridColumn: j + 2,\n            width: 30,\n            height: 30,\n            textAlign: 'center',\n            fontWeight: 'bold',\n            color: '#888',\n            lineHeight: '30px',\n            background: '#fff',\n            zIndex: 1\n          },\n          children: j + 1\n        }, j, false, {\n          fileName: _jsxFileName,\n          lineNumber: 463,\n          columnNumber: 13\n        }, this)), board.map((row, i) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              gridRow: i + 2,\n              gridColumn: 1,\n              width: 30,\n              height: 30,\n              textAlign: 'center',\n              fontWeight: 'bold',\n              color: '#888',\n              lineHeight: '30px',\n              background: '#fff',\n              zIndex: 1\n            },\n            children: i + 1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 485,\n            columnNumber: 15\n          }, this), row.map((cell, j) => {\n            const isSelected = selected.some(([x, y]) => x === i && y === j);\n            const claimed = isCellClaimed(i, j, moves);\n            let cellClass = 'board-cell';\n            if (i === center[0] && j === center[1]) cellClass += ' center';\n            if (isSelected) cellClass += ' selected';\n            if (claimed) {\n              const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n              if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';else cellClass += ' claimed';\n            }\n            let pulse = '';\n            if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n              pulse = ' pulse';\n            }\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: cellClass + pulse,\n              style: {\n                width: 30,\n                height: 30,\n                gridRow: i + 2,\n                gridColumn: j + 2\n              },\n              onClick: () => {\n                if (!claimed) handleCellClick(i, j);\n              },\n              children: cell.letter\n            }, j, false, {\n              fileName: _jsxFileName,\n              lineNumber: 518,\n              columnNumber: 19\n            }, this);\n          })]\n        }, i, true, {\n          fileName: _jsxFileName,\n          lineNumber: 483,\n          columnNumber: 13\n        }, this))]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 451,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 449,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Selected Word:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 535,\n        columnNumber: 9\n      }, this), \" \", selectedWord]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 534,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleSubmit,\n      disabled: selected.length === 0 || gameOver,\n      style: {\n        marginTop: 10\n      },\n      children: \"Submit Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 537,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handlePass,\n      disabled: gameOver,\n      style: {\n        marginLeft: 10\n      },\n      children: \"Pass Turn\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 540,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleEndGame,\n      style: {\n        marginLeft: 10\n      },\n      children: \"End Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 541,\n      columnNumber: 7\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        color: 'red',\n        marginTop: 10\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 542,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"move-history-container\",\n      style: {\n        display: 'flex',\n        justifyContent: 'space-between',\n        width: (board.length + 1) * 30\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"move-history-player1\",\n        style: {\n          textAlign: 'left',\n          minWidth: 180\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          style: {\n            color: '#3399ff'\n          },\n          children: \"Player 1\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 547,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginBottom: 8\n          },\n          children: [\"Points: \", scores['Player 1']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 548,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n          children: moves.filter(m => m.player === 'Player 1').map((move, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n            className: \"player1\",\n            children: [move.word, \" (\", move.score, \" pts)\", move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#FFA600',\n                marginLeft: 6\n              },\n              children: [\"+\", move.capturePoints, \" capture\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 554,\n              columnNumber: 19\n            }, this)]\n          }, idx, true, {\n            fileName: _jsxFileName,\n            lineNumber: 551,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 549,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 546,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"move-history-player2\",\n        style: {\n          textAlign: 'right',\n          minWidth: 180\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          style: {\n            color: '#FFA600'\n          },\n          children: \"Player 2\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 562,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginBottom: 8\n          },\n          children: [\"Points: \", scores['Player 2']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 563,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n          children: moves.filter(m => m.player === 'Player 2').map((move, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n            className: \"player2\",\n            children: [move.word, \" (\", move.score, \" pts)\", move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#3399ff',\n                marginLeft: 6\n              },\n              children: [\"+\", move.capturePoints, \" capture\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 569,\n              columnNumber: 19\n            }, this)]\n          }, idx, true, {\n            fileName: _jsxFileName,\n            lineNumber: 566,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 564,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 561,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 544,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 431,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"BcbGZaxt1PrcioqWyxXRMd4Q6ik=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","jsxDEV","_jsxDEV","letterFrequencies","letter","freq","weightedLetters","forEach","i","Math","round","push","getRandomLetter","floor","random","length","generateBoard","size","Array","from","_","j","scoreTable","getScore","word","areAdjacent","a","b","x1","y1","x2","y2","abs","isContiguous","selected","visited","Set","dfs","cell","add","join","next","has","center","createBoardWithOwnership","letters","map","row","owner","captured","pulse","App","_s","board","setBoard","turn","setTurn","setSelected","error","setError","moves","setMoves","scores","setScores","gameOver","setGameOver","winner","setWinner","dictionary","setDictionary","passCount","setPassCount","fetch","then","res","text","words","split","w","trim","toUpperCase","selectedWord","_board$i","_board$i$j","handleCellClick","idx","findIndex","x","y","newSelected","slice","concat","isCellClaimed","findEncircledGroups","currentPlayer","opponent","fill","groups","isEdge","bfs","startI","startJ","queue","group","edgeTouches","edgeSet","shift","di","dj","ni","nj","console","log","floodVisited","escapes","allFlood","cx","cy","nx","ny","groupLetters","filter","hasValidWord","len","start","handleSubmit","some","newBoard","encircledGroups","capturedCount","capturedPositions","setTimeout","score","player","positions","capturePoints","s","handlePass","c","handleEndGame","handleRestart","getCellColor","k","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","background","padding","borderRadius","margin","onClick","display","marginTop","gridTemplateColumns","border","width","position","gridRow","gridColumn","height","textAlign","fontWeight","color","lineHeight","zIndex","Fragment","isSelected","claimed","cellClass","lastMove","reverse","find","m","disabled","marginLeft","justifyContent","minWidth","marginBottom","move","_c","$RefreshReg$"],"sources":["/Users/ben/StratGO/frontend/src/App.tsx"],"sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\n\n// Letter frequencies for board generation\nconst letterFrequencies = [\n  { letter: 'E', freq: 12.7 }, { letter: 'T', freq: 9.1 }, { letter: 'A', freq: 8.2 },\n  { letter: 'O', freq: 7.5 }, { letter: 'I', freq: 7.0 }, { letter: 'N', freq: 6.7 },\n  { letter: 'S', freq: 6.3 }, { letter: 'H', freq: 6.1 }, { letter: 'R', freq: 6.0 },\n  { letter: 'D', freq: 4.3 }, { letter: 'L', freq: 4.0 }, { letter: 'C', freq: 2.8 },\n  { letter: 'U', freq: 2.8 }, { letter: 'M', freq: 2.4 }, { letter: 'W', freq: 2.4 },\n  { letter: 'F', freq: 2.2 }, { letter: 'G', freq: 2.0 }, { letter: 'Y', freq: 2.0 },\n  { letter: 'P', freq: 1.9 }, { letter: 'B', freq: 1.5 }, { letter: 'V', freq: 1.0 },\n  { letter: 'K', freq: 0.8 }, { letter: 'J', freq: 0.15 }, { letter: 'X', freq: 0.15 },\n  { letter: 'Q', freq: 0.10 }, { letter: 'Z', freq: 0.07 },\n];\nconst weightedLetters: string[] = [];\nletterFrequencies.forEach(({ letter, freq }) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({ length: size }, (_, i) =>\n    Array.from({ length: size }, (_, j) => getRandomLetter())\n  );\n}\n\nconst scoreTable: { [len: number]: number } = {\n  2: 2, 3: 3, 4: 4, 5: 6, 6: 8, 7: 11, 8: 14, 9: 19, 10: 24\n};\nfunction getScore(word: string) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\n\nfunction areAdjacent(a: [number, number], b: [number, number]) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected: [number, number][]) {\n  if (selected.length <= 1) return true;\n  const visited = new Set<string>();\n  function dfs(cell: [number, number]) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\n\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\ninterface Cell {\n  letter: string;\n  owner: null | 'Player 1' | 'Player 2';\n  captured: boolean;\n  pulse: boolean;\n}\n\nfunction createBoardWithOwnership(letters: string[][]): Cell[][] {\n  return letters.map(row => row.map(letter => ({ letter, owner: null, captured: false, pulse: false })));\n}\n// Figma UI update END\n\nfunction App() {\n  const [board, setBoard] = useState<Cell[][]>([]);\n  const [turn, setTurn] = useState<'Player 1' | 'Player 2'>('Player 1');\n  const [selected, setSelected] = useState<[number, number][]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [moves, setMoves] = useState<{ player: string, word: string, positions: [number, number][], score: number, capturePoints: number }[]>([]);\n  const [scores, setScores] = useState<{ [player: string]: number }>({ 'Player 1': 0, 'Player 2': 0 });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState<string | null>(null);\n  const [dictionary, setDictionary] = useState<Set<string> | null>(null);\n  const [passCount, setPassCount] = useState(0);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt')\n      .then(res => res.text())\n      .then(text => {\n        const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n        setDictionary(new Set(words));\n      });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => board[i]?.[j]?.letter || '').join('');\n\n  // Handle cell click\n  const handleCellClick = (i: number, j: number) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected: [number, number][];\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i: number, j: number, moves: { positions: [number, number][] }[]) => {\n    return board[i][j].owner !== null;\n  };\n\n  // --- Encirclement Logic Version 1 ---\n  // This is the preferred and tested encirclement logic as of [date].\n  // To roll back to this version, search for 'Encirclement Logic Version 1'.\n  // The logic allows capture even if there are unclaimed tiles adjacent, as long as those unclaimed tiles are also fully surrounded and cannot form a valid word.\n  // The previous logic is commented out below for easy rollback.\n  // --- END Encirclement Logic Version 1 ---\n  function findEncircledGroups(board: Cell[][], currentPlayer: 'Player 1' | 'Player 2', dictionary: Set<string>): [number, number][][] {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({ length: size }, () => Array(size).fill(false));\n    const groups: [number, number][][] = [];\n    function isEdge(i: number, j: number) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI: number, startJ: number) {\n      const queue: [number, number][] = [[startI, startJ]];\n      const group: [number, number][] = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set<string>();\n      while (queue.length) {\n        const [i, j] = queue.shift()!;\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [\n          [-1, 0], [1, 0], [0, -1], [0, 1]\n        ]) {\n          const ni = i + di, nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return { group, edgeTouches };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const { group, edgeTouches } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // --- BEGIN: Old logic for easy rollback ---\n          /*\n          // New encirclement logic: expand group to include any unclaimed tiles fully enclosed by the boundary. Only capture if no valid word can be formed from the unclaimed tiles inside the boundary.\n          // 1. Find all unclaimed tiles orthogonally connected to the group that are also fully enclosed (do not touch more than one edge or connect to outside)\n          const groupSet = new Set(group.map(([x, y]) => `${x},${y}`));\n          const enclosedUnclaimed: [number, number][] = [];\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (board[ni][nj].owner === null && !groupSet.has(`${ni},${nj}`)) {\n                // Check if this unclaimed tile is fully enclosed (BFS to see if it can reach the edge without passing through currentPlayer's tiles)\n                const queue: [number, number][] = [[ni, nj]];\n                const visitedUnclaimed = new Set([`${ni},${nj}`]);\n                let touchesEdge = false;\n                let escapes = false;\n                while (queue.length) {\n                  const [ui, uj] = queue.shift()!;\n                  if (isEdge(ui, uj)) touchesEdge = true;\n                  for (const [udi, udj] of [\n                    [-1, 0], [1, 0], [0, -1], [0, 1]\n                  ]) {\n                    const vi = ui + udi, vj = uj + udj;\n                    if (vi < 0 || vj < 0 || vi >= size || vj >= size) continue;\n                    if (board[vi][vj].owner === currentPlayer) continue; // blocked by current player's tile\n                    if (!visitedUnclaimed.has(`${vi},${vj}`) && board[vi][vj].owner === null) {\n                      visitedUnclaimed.add(`${vi},${vj}`);\n                      queue.push([vi, vj]);\n                    }\n                  }\n                }\n                if (!touchesEdge) {\n                  enclosedUnclaimed.push([ni, nj]);\n                  groupSet.add(`${ni},${nj}`);\n                }\n              }\n            }\n          }\n          // Now, group + enclosedUnclaimed is the full encircled area\n          const allEncircled = [...group, ...enclosedUnclaimed];\n          const groupLetters = allEncircled.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allEncircled);\n            groups.push(group);\n          }\n          */\n          // --- END: Old logic for easy rollback ---\n          // New logic: flood fill from group and all orthogonally adjacent unclaimed tiles. If the fill cannot reach the board edge without crossing currentPlayer's tiles, and no valid word can be formed from the unclaimed tiles, capture the group.\n          const floodVisited = Array.from({ length: size }, () => Array(size).fill(false));\n          const queue: [number, number][] = [...group];\n          group.forEach(([x, y]) => { floodVisited[x][y] = true; });\n          // Add all orthogonally adjacent unclaimed tiles to the queue\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (!floodVisited[ni][nj] && board[ni][nj].owner === null) {\n                queue.push([ni, nj]);\n                floodVisited[ni][nj] = true;\n              }\n            }\n          }\n          let escapes = false;\n          let allFlood: [number, number][] = [];\n          while (queue.length) {\n            const [cx, cy] = queue.shift()!;\n            allFlood.push([cx, cy]);\n            if (isEdge(cx, cy)) escapes = true;\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const nx = cx + di, ny = cy + dj;\n              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;\n              if (floodVisited[nx][ny]) continue;\n              if (board[nx][ny].owner === currentPlayer) continue; // blocked by current player's tile\n              floodVisited[nx][ny] = true;\n              queue.push([nx, ny]);\n            }\n          }\n          if (escapes) {\n            console.log('Flood fill escapes to edge, not encircled');\n            continue;\n          }\n          // Only capture if no valid word can be formed from the unclaimed tiles in the flood area\n          const groupLetters = allFlood.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allFlood);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({ ...cell })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions: [number, number][] = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({ ...cell, pulse: false }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, { player: turn, word, positions: [...selected], score, capturePoints: capturedCount }]);\n    setScores(s => ({ ...s, [turn]: s[turn] + score + capturedCount }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n      else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n      else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n    else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n    else setWinner('Draw');\n  };\n\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({ 'Player 1': 0, 'Player 2': 0 });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i: number, j: number, moves: { player: string, positions: [number, number][] }[]) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n\n  return (\n    <div className=\"App\">\n      <h1>Word Strategy Game (Local Two-Player)</h1>\n      <div><strong>Current Turn:</strong> {turn}</div>\n      {/* Figma UI update START: Score Panel */}\n      <div className=\"score-panel\">\n        <span className=\"player1\">Player 1: {scores['Player 1']}</span>\n        <span className=\"player2\">Player 2: {scores['Player 2']}</span>\n      </div>\n      {/* Figma UI update END */}\n      {gameOver && (\n        <div style={{ background: '#eee', padding: 20, borderRadius: 8, margin: 20 }}>\n          <h2>Game Over</h2>\n          {winner === 'Draw' ? <div><strong>It's a draw!</strong></div> : <div><strong>{winner} wins!</strong></div>}\n          <button onClick={handleRestart}>Restart Game</button>\n        </div>\n      )}\n      {/* Column numbers (1-based, aligned above columns) */}\n      {/* Removed the flex div with the numbers at the top as requested */}\n      <div style={{ display: 'inline-block', marginTop: 20 }}>\n        {/* Board rows with row numbers (1-based, aligned left) */}\n        <div\n          style={{\n            display: 'grid',\n            gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n            marginTop: 20,\n            border: '2px solid #333',\n            width: (board.length + 1) * 30,\n            position: 'relative',\n          }}\n        >\n          {/* Column numbers (1-based) */}\n          {board[0] && board[0].map((_, j) => (\n            <div\n              key={j}\n              style={{\n                gridRow: 1,\n                gridColumn: j + 2,\n                width: 30,\n                height: 30,\n                textAlign: 'center',\n                fontWeight: 'bold',\n                color: '#888',\n                lineHeight: '30px',\n                background: '#fff',\n                zIndex: 1,\n              }}\n            >\n              {j + 1}\n            </div>\n          ))}\n          {/* Row numbers (1-based) and board cells */}\n          {board.map((row, i) => (\n            <React.Fragment key={i}>\n              {/* Row number */}\n              <div\n                style={{\n                  gridRow: i + 2,\n                  gridColumn: 1,\n                  width: 30,\n                  height: 30,\n                  textAlign: 'center',\n                  fontWeight: 'bold',\n                  color: '#888',\n                  lineHeight: '30px',\n                  background: '#fff',\n                  zIndex: 1,\n                }}\n              >\n                {i + 1}\n              </div>\n              {/* Board cells */}\n              {row.map((cell, j) => {\n                const isSelected = selected.some(([x, y]) => x === i && y === j);\n                const claimed = isCellClaimed(i, j, moves);\n                let cellClass = 'board-cell';\n                if (i === center[0] && j === center[1]) cellClass += ' center';\n                if (isSelected) cellClass += ' selected';\n                if (claimed) {\n                  const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n                  if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';\n                  else cellClass += ' claimed';\n                }\n                let pulse = '';\n                if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n                  pulse = ' pulse';\n                }\n                return (\n                  <div\n                    key={j}\n                    className={cellClass + pulse}\n                    style={{ width: 30, height: 30, gridRow: i + 2, gridColumn: j + 2 }}\n                    onClick={() => {\n                      if (!claimed) handleCellClick(i, j);\n                    }}\n                  >\n                    {cell.letter}\n                  </div>\n                );\n              })}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n      <div style={{ marginTop: 20 }}>\n        <strong>Selected Word:</strong> {selectedWord}\n      </div>\n      <button onClick={handleSubmit} disabled={selected.length === 0 || gameOver} style={{ marginTop: 10 }}>\n        Submit Word\n      </button>\n      <button onClick={handlePass} disabled={gameOver} style={{ marginLeft: 10 }}>Pass Turn</button>\n      <button onClick={handleEndGame} style={{ marginLeft: 10 }}>End Game</button>\n      {error && <div style={{ color: 'red', marginTop: 10 }}>{error}</div>}\n      {/* Figma UI update START: Move History */}\n      <div className=\"move-history-container\" style={{ display: 'flex', justifyContent: 'space-between', width: (board.length + 1) * 30 }}>\n        {/* Player 1 Move History (Left) */}\n        <div className=\"move-history-player1\" style={{ textAlign: 'left', minWidth: 180 }}>\n          <h2 style={{ color: '#3399ff' }}>Player 1</h2>\n          <div style={{ fontWeight: 'bold', marginBottom: 8 }}>Points: {scores['Player 1']}</div>\n          <ol>\n            {moves.filter(m => m.player === 'Player 1').map((move, idx) => (\n              <li key={idx} className=\"player1\">\n                {move.word} ({move.score} pts)\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#FFA600', marginLeft: 6 }}>+{move.capturePoints} capture</span>\n                )}\n              </li>\n            ))}\n          </ol>\n        </div>\n        {/* Player 2 Move History (Right) */}\n        <div className=\"move-history-player2\" style={{ textAlign: 'right', minWidth: 180 }}>\n          <h2 style={{ color: '#FFA600' }}>Player 2</h2>\n          <div style={{ fontWeight: 'bold', marginBottom: 8 }}>Points: {scores['Player 2']}</div>\n          <ol>\n            {moves.filter(m => m.player === 'Player 2').map((move, idx) => (\n              <li key={idx} className=\"player2\">\n                {move.word} ({move.score} pts)\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#3399ff', marginLeft: 6 }}>+{move.capturePoints} capture</span>\n                )}\n              </li>\n            ))}\n          </ol>\n        </div>\n      </div>\n      {/* Figma UI update END */}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}