{"ast":null,"code":"var _jsxFileName = \"/Users/ben/StratGO/frontend/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Letter frequencies for board generation\nconst letterFrequencies = [{\n  letter: 'E',\n  freq: 12.7\n}, {\n  letter: 'T',\n  freq: 9.1\n}, {\n  letter: 'A',\n  freq: 8.2\n}, {\n  letter: 'O',\n  freq: 7.5\n}, {\n  letter: 'I',\n  freq: 7.0\n}, {\n  letter: 'N',\n  freq: 6.7\n}, {\n  letter: 'S',\n  freq: 6.3\n}, {\n  letter: 'H',\n  freq: 6.1\n}, {\n  letter: 'R',\n  freq: 6.0\n}, {\n  letter: 'D',\n  freq: 4.3\n}, {\n  letter: 'L',\n  freq: 4.0\n}, {\n  letter: 'C',\n  freq: 2.8\n}, {\n  letter: 'U',\n  freq: 2.8\n}, {\n  letter: 'M',\n  freq: 2.4\n}, {\n  letter: 'W',\n  freq: 2.4\n}, {\n  letter: 'F',\n  freq: 2.2\n}, {\n  letter: 'G',\n  freq: 2.0\n}, {\n  letter: 'Y',\n  freq: 2.0\n}, {\n  letter: 'P',\n  freq: 1.9\n}, {\n  letter: 'B',\n  freq: 1.5\n}, {\n  letter: 'V',\n  freq: 1.0\n}, {\n  letter: 'K',\n  freq: 0.8\n}, {\n  letter: 'J',\n  freq: 0.15\n}, {\n  letter: 'X',\n  freq: 0.15\n}, {\n  letter: 'Q',\n  freq: 0.10\n}, {\n  letter: 'Z',\n  freq: 0.07\n}];\nconst weightedLetters = [];\nletterFrequencies.forEach(({\n  letter,\n  freq\n}) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({\n    length: size\n  }, (_, i) => Array.from({\n    length: size\n  }, (_, j) => getRandomLetter()));\n}\nconst scoreTable = {\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 6,\n  6: 8,\n  7: 11,\n  8: 14,\n  9: 19,\n  10: 24\n};\nfunction getScore(word) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\nfunction areAdjacent(a, b) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected) {\n  if (selected.length <= 1) return true;\n  const visited = new Set();\n  function dfs(cell) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\n\nfunction createBoardWithOwnership(letters) {\n  return letters.map(row => row.map(letter => ({\n    letter,\n    owner: null,\n    captured: false,\n    pulse: false\n  })));\n}\n// Figma UI update END\n\nfunction App() {\n  _s();\n  const [board, setBoard] = useState([]);\n  const [turn, setTurn] = useState('Player 1');\n  const [selected, setSelected] = useState([]);\n  const [error, setError] = useState(null);\n  const [moves, setMoves] = useState([]);\n  const [scores, setScores] = useState({\n    'Player 1': 0,\n    'Player 2': 0\n  });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [dictionary, setDictionary] = useState(null);\n  const [passCount, setPassCount] = useState(0);\n  // Add modal state\n  const [showInstructions, setShowInstructions] = useState(false);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt').then(res => res.text()).then(text => {\n      const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n      setDictionary(new Set(words));\n    });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => {\n    var _board$i, _board$i$j;\n    return ((_board$i = board[i]) === null || _board$i === void 0 ? void 0 : (_board$i$j = _board$i[j]) === null || _board$i$j === void 0 ? void 0 : _board$i$j.letter) || '';\n  }).join('');\n\n  // Handle cell click\n  const handleCellClick = (i, j) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected;\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i, j, moves) => {\n    return board[i][j].owner !== null;\n  };\n\n  // --- Encirclement Logic Version 1 ---\n  // This is the preferred and tested encirclement logic as of [date].\n  // To roll back to this version, search for 'Encirclement Logic Version 1'.\n  // The logic allows capture even if there are unclaimed tiles adjacent, as long as those unclaimed tiles are also fully surrounded and cannot form a valid word.\n  // The previous logic is commented out below for easy rollback.\n  // --- END Encirclement Logic Version 1 ---\n  function findEncircledGroups(board, currentPlayer, dictionary) {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({\n      length: size\n    }, () => Array(size).fill(false));\n    const groups = [];\n    function isEdge(i, j) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI, startJ) {\n      const queue = [[startI, startJ]];\n      const group = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set();\n      while (queue.length) {\n        const [i, j] = queue.shift();\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n          const ni = i + di,\n            nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return {\n        group,\n        edgeTouches\n      };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const {\n            group,\n            edgeTouches\n          } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // --- BEGIN: Old logic for easy rollback ---\n          /*\n          // New encirclement logic: expand group to include any unclaimed tiles fully enclosed by the boundary. Only capture if no valid word can be formed from the unclaimed tiles inside the boundary.\n          // 1. Find all unclaimed tiles orthogonally connected to the group that are also fully enclosed (do not touch more than one edge or connect to outside)\n          const groupSet = new Set(group.map(([x, y]) => `${x},${y}`));\n          const enclosedUnclaimed: [number, number][] = [];\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (board[ni][nj].owner === null && !groupSet.has(`${ni},${nj}`)) {\n                // Check if this unclaimed tile is fully enclosed (BFS to see if it can reach the edge without passing through currentPlayer's tiles)\n                const queue: [number, number][] = [[ni, nj]];\n                const visitedUnclaimed = new Set([`${ni},${nj}`]);\n                let touchesEdge = false;\n                let escapes = false;\n                while (queue.length) {\n                  const [ui, uj] = queue.shift()!;\n                  if (isEdge(ui, uj)) touchesEdge = true;\n                  for (const [udi, udj] of [\n                    [-1, 0], [1, 0], [0, -1], [0, 1]\n                  ]) {\n                    const vi = ui + udi, vj = uj + udj;\n                    if (vi < 0 || vj < 0 || vi >= size || vj >= size) continue;\n                    if (board[vi][vj].owner === currentPlayer) continue; // blocked by current player's tile\n                    if (!visitedUnclaimed.has(`${vi},${vj}`) && board[vi][vj].owner === null) {\n                      visitedUnclaimed.add(`${vi},${vj}`);\n                      queue.push([vi, vj]);\n                    }\n                  }\n                }\n                if (!touchesEdge) {\n                  enclosedUnclaimed.push([ni, nj]);\n                  groupSet.add(`${ni},${nj}`);\n                }\n              }\n            }\n          }\n          // Now, group + enclosedUnclaimed is the full encircled area\n          const allEncircled = [...group, ...enclosedUnclaimed];\n          const groupLetters = allEncircled.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allEncircled);\n            groups.push(group);\n          }\n          */\n          // --- END: Old logic for easy rollback ---\n          // New logic: flood fill from group and all orthogonally adjacent unclaimed tiles. If the fill cannot reach the board edge without crossing currentPlayer's tiles, and no valid word can be formed from the unclaimed tiles, capture the group.\n          const floodVisited = Array.from({\n            length: size\n          }, () => Array(size).fill(false));\n          const queue = [...group];\n          group.forEach(([x, y]) => {\n            floodVisited[x][y] = true;\n          });\n          // Add all orthogonally adjacent unclaimed tiles to the queue\n          for (const [x, y] of group) {\n            for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n              const ni = x + di,\n                nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (!floodVisited[ni][nj] && board[ni][nj].owner === null) {\n                queue.push([ni, nj]);\n                floodVisited[ni][nj] = true;\n              }\n            }\n          }\n          let escapes = false;\n          let allFlood = [];\n          while (queue.length) {\n            const [cx, cy] = queue.shift();\n            allFlood.push([cx, cy]);\n            if (isEdge(cx, cy)) escapes = true;\n            for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n              const nx = cx + di,\n                ny = cy + dj;\n              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;\n              if (floodVisited[nx][ny]) continue;\n              if (board[nx][ny].owner === currentPlayer) continue; // blocked by current player's tile\n              floodVisited[nx][ny] = true;\n              queue.push([nx, ny]);\n            }\n          }\n          if (escapes) {\n            console.log('Flood fill escapes to edge, not encircled');\n            continue;\n          }\n          // Only capture if no valid word can be formed from the unclaimed tiles in the flood area\n          const groupLetters = allFlood.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allFlood);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({\n      ...cell\n    })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({\n        ...cell,\n        pulse: false\n      }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, {\n      player: turn,\n      word,\n      positions: [...selected],\n      score,\n      capturePoints: capturedCount\n    }]);\n    setScores(s => ({\n      ...s,\n      [turn]: s[turn] + score + capturedCount\n    }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n  };\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({\n      'Player 1': 0,\n      'Player 2': 0\n    });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i, j, moves) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n\n  // Replace the instructionsMarkdown and ReactMarkdown usage with the .txt content in a <pre> tag\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Word Strategy Game (Local Two-Player)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 436,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Current Turn:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 12\n      }, this), \" \", turn]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"score-panel\",\n        style: {\n          display: 'flex',\n          gap: 40,\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"player1\",\n          children: [\"Player 1: \", scores['Player 1']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 441,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"player2\",\n          children: [\"Player 2: \", scores['Player 2']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 442,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 440,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 439,\n      columnNumber: 7\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        background: '#eee',\n        padding: 20,\n        borderRadius: 8,\n        margin: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Game Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 448,\n        columnNumber: 11\n      }, this), winner === 'Draw' ? /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"It's a draw!\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 449,\n          columnNumber: 37\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 449,\n        columnNumber: 32\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: [winner, \" wins!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 449,\n          columnNumber: 80\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 449,\n        columnNumber: 75\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleRestart,\n        children: \"Restart Game\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 450,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 447,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'inline-block',\n        marginTop: 20\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'grid',\n          gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n          marginTop: 20,\n          border: '3px solid #000',\n          width: (board.length + 1) * 30,\n          position: 'relative'\n        },\n        children: [board[0] && board[0].map((_, j) => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            gridRow: 1,\n            gridColumn: j + 2,\n            width: 30,\n            height: 30,\n            textAlign: 'center',\n            fontWeight: 'bold',\n            color: '#888',\n            lineHeight: '30px',\n            background: '#fff',\n            zIndex: 1\n          },\n          children: j + 1\n        }, j, false, {\n          fileName: _jsxFileName,\n          lineNumber: 469,\n          columnNumber: 13\n        }, this)), board.map((row, i) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              gridRow: i + 2,\n              gridColumn: 1,\n              width: 30,\n              height: 30,\n              textAlign: 'center',\n              fontWeight: 'bold',\n              color: '#888',\n              lineHeight: '30px',\n              background: '#fff',\n              zIndex: 1\n            },\n            children: i + 1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 491,\n            columnNumber: 15\n          }, this), row.map((cell, j) => {\n            const isSelected = selected.some(([x, y]) => x === i && y === j);\n            const claimed = isCellClaimed(i, j, moves);\n            let cellClass = 'board-cell';\n            if (i === center[0] && j === center[1]) cellClass += ' center';\n            if (isSelected) cellClass += ' selected';\n            if (claimed) {\n              const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n              if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';else cellClass += ' claimed';\n            }\n            let pulse = '';\n            if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n              pulse = ' pulse';\n            }\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: cellClass + pulse,\n              style: {\n                width: 30,\n                height: 30,\n                gridRow: i + 2,\n                gridColumn: j + 2\n              },\n              onClick: () => {\n                if (!claimed) handleCellClick(i, j);\n              },\n              children: cell.letter\n            }, j, false, {\n              fileName: _jsxFileName,\n              lineNumber: 524,\n              columnNumber: 19\n            }, this);\n          })]\n        }, i, true, {\n          fileName: _jsxFileName,\n          lineNumber: 489,\n          columnNumber: 13\n        }, this))]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 457,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 455,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Selected Word:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 541,\n        columnNumber: 9\n      }, this), \" \", selectedWord]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 540,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        width: (board.length + 1) * 30,\n        margin: '30px auto 0 auto'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"player-score-left\",\n        style: {\n          textAlign: 'left',\n          minWidth: 120\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            color: '#3399ff',\n            fontWeight: 'bold',\n            fontSize: 48,\n            lineHeight: 1\n          },\n          children: scores['Player 1']\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 546,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            fontSize: 18\n          },\n          children: \"Player 1\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 547,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 545,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          flex: 1,\n          textAlign: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            fontSize: 32,\n            marginBottom: 10\n          },\n          children: selectedWord\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 550,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"submit-word-btn\",\n          style: {\n            background: '#000',\n            color: '#fff',\n            border: 'none',\n            borderRadius: 999,\n            padding: '16px 48px',\n            fontWeight: 'bold',\n            fontSize: 20,\n            margin: '0 auto',\n            display: 'block',\n            boxShadow: '0 2px 8px rgba(0,0,0,0.08)',\n            cursor: 'pointer',\n            marginTop: 10\n          },\n          onClick: handleSubmit,\n          disabled: selected.length === 0 || gameOver,\n          children: \"Submit Word\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 551,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 549,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"player-score-right\",\n        style: {\n          textAlign: 'right',\n          minWidth: 120\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            color: '#FFA600',\n            fontWeight: 'bold',\n            fontSize: 48,\n            lineHeight: 1\n          },\n          children: scores['Player 2']\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 574,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            fontSize: 18\n          },\n          children: \"Player 2\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 575,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 573,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 544,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'space-between',\n        width: (board.length + 1) * 30,\n        margin: '30px auto 0 auto'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          textAlign: 'left',\n          minWidth: 180\n        },\n        children: [moves.filter(m => m.player === 'Player 1').map((move, idx, arr) => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            fontWeight: idx === arr.length - 1 ? 'bold' : 'normal',\n            borderRadius: 6,\n            padding: 0,\n            marginBottom: 2,\n            textAlign: 'left'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: move.word\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 584,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            children: [move.score, move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#FFA600',\n                marginLeft: 4\n              },\n              children: [\"+ \", move.capturePoints]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 588,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 585,\n            columnNumber: 15\n          }, this)]\n        }, idx, true, {\n          fileName: _jsxFileName,\n          lineNumber: 583,\n          columnNumber: 13\n        }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            borderTop: '2px solid #222',\n            margin: '8px 0'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 593,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginTop: 4\n          },\n          children: [\"TOTAL \", scores['Player 1']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 594,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 581,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          textAlign: 'right',\n          minWidth: 180\n        },\n        children: [moves.filter(m => m.player === 'Player 2').map((move, idx, arr) => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            fontWeight: idx === arr.length - 1 ? 'bold' : 'normal',\n            borderRadius: 6,\n            padding: 0,\n            marginBottom: 2,\n            textAlign: 'left'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: move.word\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 600,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            children: [move.score, move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#3399ff',\n                marginLeft: 4\n              },\n              children: [\"+ \", move.capturePoints]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 604,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 601,\n            columnNumber: 15\n          }, this)]\n        }, idx, true, {\n          fileName: _jsxFileName,\n          lineNumber: 599,\n          columnNumber: 13\n        }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            borderTop: '2px solid #222',\n            margin: '8px 0'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 609,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginTop: 4\n          },\n          children: [\"TOTAL \", scores['Player 2']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 610,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 597,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 579,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handlePass,\n      disabled: gameOver,\n      style: {\n        marginLeft: 10\n      },\n      children: \"Pass Turn\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 613,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleEndGame,\n      style: {\n        marginLeft: 10\n      },\n      children: \"End Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 614,\n      columnNumber: 7\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        color: 'red',\n        marginTop: 10\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 615,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"move-history-container\",\n      style: {\n        display: 'none'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"move-history-player1\",\n        style: {\n          textAlign: 'left',\n          minWidth: 180\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          style: {\n            color: '#3399ff'\n          },\n          children: \"Player 1\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 620,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginBottom: 8\n          },\n          children: [\"Points: \", scores['Player 1']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 621,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n          children: moves.filter(m => m.player === 'Player 1').map((move, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n            className: \"player1\",\n            children: [move.word, \" (\", move.score, \" pts)\", move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#FFA600',\n                marginLeft: 6\n              },\n              children: [\"+\", move.capturePoints, \" capture\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 627,\n              columnNumber: 19\n            }, this)]\n          }, idx, true, {\n            fileName: _jsxFileName,\n            lineNumber: 624,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 622,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 619,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"move-history-player2\",\n        style: {\n          textAlign: 'right',\n          minWidth: 180\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          style: {\n            color: '#FFA600'\n          },\n          children: \"Player 2\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 635,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontWeight: 'bold',\n            marginBottom: 8\n          },\n          children: [\"Points: \", scores['Player 2']]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 636,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n          children: moves.filter(m => m.player === 'Player 2').map((move, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n            className: \"player2\",\n            children: [move.word, \" (\", move.score, \" pts)\", move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                color: '#3399ff',\n                marginLeft: 6\n              },\n              children: [\"+\", move.capturePoints, \" capture\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 642,\n              columnNumber: 19\n            }, this)]\n          }, idx, true, {\n            fileName: _jsxFileName,\n            lineNumber: 639,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 637,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 634,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 617,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 40,\n        textAlign: 'center'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setShowInstructions(true),\n        style: {\n          padding: '12px 32px',\n          borderRadius: 24,\n          background: '#222',\n          color: '#fff',\n          fontWeight: 'bold',\n          fontSize: 18,\n          border: 'none',\n          cursor: 'pointer'\n        },\n        children: \"Show Instructions\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 652,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 651,\n      columnNumber: 7\n    }, this), showInstructions && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        background: 'rgba(0,0,0,0.5)',\n        zIndex: 1000,\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          background: '#fff',\n          borderRadius: 12,\n          padding: 32,\n          maxWidth: 600,\n          width: '90%',\n          boxShadow: '0 4px 24px rgba(0,0,0,0.2)',\n          position: 'relative'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setShowInstructions(false),\n          style: {\n            position: 'absolute',\n            top: 16,\n            right: 16,\n            background: 'none',\n            border: 'none',\n            fontSize: 24,\n            cursor: 'pointer'\n          },\n          children: \"\\xD7\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 659,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Game Instructions\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 660,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            maxHeight: 400,\n            overflowY: 'auto',\n            textAlign: 'left',\n            fontFamily: 'inherit',\n            fontSize: 16\n          },\n          children: /*#__PURE__*/_jsxDEV(\"pre\", {\n            style: {\n              whiteSpace: 'pre-wrap',\n              wordBreak: 'break-word',\n              margin: 0\n            },\n            children: `[Working Title]: A Word Strategy Game of Territory and Capture\nOverview\nA two-player game combining the strategic depth of Go with the linguistic creativity of Scrabble. Players take turns forming words on a 19x19 board to earn points and capture territory.\nObjective\nScore the highest number of points by:\n- Forming valid words on the board (word score)\n- Capturing your opponent’s tiles through strategic encirclement (tile capture)\nComponents\n- 19x19 game board populated with randomly generated letters per game\n- Two sets of tiles (Black and White), one for each player\n- A valid dictionary for word verification (e.g., Scrabble dictionary)\n- Game software to validate moves and track scores\nSetup\n- Each game begins with a freshly generated 19x19 board of letters.\n- The distribution is based on common letter frequency, and may include pre-baked eight-letter words for bonus opportunities.\n- Players are assigned either White or Black tiles.\n- The central square of the board must be part of the first move.\nGameplay\nStarting the Game:\n- Player 1 begins by forming a word using contiguous tiles (touching on sides or corners).\n- The word must be at least two letters long and must include the center square.\n- Words can be placed in any direction (horizontally, vertically, or diagonally).\n- Player 2 then makes their move, and players alternate turns.\n\nForming Words:\n- On a turn, a player must place a new word on the board using available letters.\n- Words must be valid as determined by the shared dictionary. The system will automatically verify validity.\n- Words do not need to connect to existing words unless used to break an encirclement.\n- Multiple words may exist independently on the board.\nScoring\nWord Score\nPoints are awarded based on the length of each valid word:\nWord Length\nPoints\n2 letters\n2 pts\n3 letters\n3 pts\n4 letters\n4 pts\n5 letters\n6 pts\n6 letters\n8 pts\n7 letters\n11 pts\n8 letters\n14 pts\n9 letters\n19 pts\n10 letters\n24 pts\n11+ letters\n30 pts\nCapture Score\n- When a player successfully encircles a group of their opponent’s tiles, those tiles are captured.\n- Each captured tile adds 1 point to the capturing player’s score.\n- A tile can only be captured once; it cannot be part of multiple encirclements.\nEncirclement Rules\nA group of tiles is considered encircled and captured if:\n1. The opponent’s tiles are completely surrounded by the current player’s tiles.\n2. The surrounded player cannot make a legitimate contiguous move (side-touching only; corner-touching doesn’t count).\n3. There are no valid words possible inside the encircled area.\n4. Encirclement is also valid if:\n   - The opponent is blocked against a single edge of the board and surrounded on all other sides.\n   - However, if they touch more than one edge, it's not considered encircled.\n\nThe software will automatically detect and indicate when an encirclement occurs, and display how many tiles have been captured.\nEnd of Game\nThe game ends when:\n- No valid moves remain for either player, or\n- A player resigns\nWinning\nThe player with the highest combined score wins. The total score is:\n- Word Score (sum of all valid words created)\n- Capture Score (number of opponent tiles captured)\nLive Scoring\nAfter each move, the current scores (word + capture) are displayed so both players can monitor progress.\n`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 662,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 661,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 658,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 657,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 435,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"QJ2/B4oE6yrrZt7WV1rsrrRKibE=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","jsxDEV","_jsxDEV","letterFrequencies","letter","freq","weightedLetters","forEach","i","Math","round","push","getRandomLetter","floor","random","length","generateBoard","size","Array","from","_","j","scoreTable","getScore","word","areAdjacent","a","b","x1","y1","x2","y2","abs","isContiguous","selected","visited","Set","dfs","cell","add","join","next","has","center","createBoardWithOwnership","letters","map","row","owner","captured","pulse","App","_s","board","setBoard","turn","setTurn","setSelected","error","setError","moves","setMoves","scores","setScores","gameOver","setGameOver","winner","setWinner","dictionary","setDictionary","passCount","setPassCount","showInstructions","setShowInstructions","fetch","then","res","text","words","split","w","trim","toUpperCase","selectedWord","_board$i","_board$i$j","handleCellClick","idx","findIndex","x","y","newSelected","slice","concat","isCellClaimed","findEncircledGroups","currentPlayer","opponent","fill","groups","isEdge","bfs","startI","startJ","queue","group","edgeTouches","edgeSet","shift","di","dj","ni","nj","console","log","floodVisited","escapes","allFlood","cx","cy","nx","ny","groupLetters","filter","hasValidWord","len","start","handleSubmit","some","newBoard","encircledGroups","capturedCount","capturedPositions","setTimeout","score","player","positions","capturePoints","s","handlePass","c","handleEndGame","handleRestart","getCellColor","k","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","display","gap","alignItems","background","padding","borderRadius","margin","onClick","marginTop","gridTemplateColumns","border","width","position","gridRow","gridColumn","height","textAlign","fontWeight","color","lineHeight","zIndex","Fragment","isSelected","claimed","cellClass","lastMove","reverse","find","m","justifyContent","minWidth","fontSize","flex","marginBottom","boxShadow","cursor","disabled","move","arr","marginLeft","borderTop","top","left","maxWidth","right","maxHeight","overflowY","fontFamily","whiteSpace","wordBreak","_c","$RefreshReg$"],"sources":["/Users/ben/StratGO/frontend/src/App.tsx"],"sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\nimport ReactMarkdown from 'react-markdown';\n\n// Letter frequencies for board generation\nconst letterFrequencies = [\n  { letter: 'E', freq: 12.7 }, { letter: 'T', freq: 9.1 }, { letter: 'A', freq: 8.2 },\n  { letter: 'O', freq: 7.5 }, { letter: 'I', freq: 7.0 }, { letter: 'N', freq: 6.7 },\n  { letter: 'S', freq: 6.3 }, { letter: 'H', freq: 6.1 }, { letter: 'R', freq: 6.0 },\n  { letter: 'D', freq: 4.3 }, { letter: 'L', freq: 4.0 }, { letter: 'C', freq: 2.8 },\n  { letter: 'U', freq: 2.8 }, { letter: 'M', freq: 2.4 }, { letter: 'W', freq: 2.4 },\n  { letter: 'F', freq: 2.2 }, { letter: 'G', freq: 2.0 }, { letter: 'Y', freq: 2.0 },\n  { letter: 'P', freq: 1.9 }, { letter: 'B', freq: 1.5 }, { letter: 'V', freq: 1.0 },\n  { letter: 'K', freq: 0.8 }, { letter: 'J', freq: 0.15 }, { letter: 'X', freq: 0.15 },\n  { letter: 'Q', freq: 0.10 }, { letter: 'Z', freq: 0.07 },\n];\nconst weightedLetters: string[] = [];\nletterFrequencies.forEach(({ letter, freq }) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({ length: size }, (_, i) =>\n    Array.from({ length: size }, (_, j) => getRandomLetter())\n  );\n}\n\nconst scoreTable: { [len: number]: number } = {\n  2: 2, 3: 3, 4: 4, 5: 6, 6: 8, 7: 11, 8: 14, 9: 19, 10: 24\n};\nfunction getScore(word: string) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\n\nfunction areAdjacent(a: [number, number], b: [number, number]) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected: [number, number][]) {\n  if (selected.length <= 1) return true;\n  const visited = new Set<string>();\n  function dfs(cell: [number, number]) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\n\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\ninterface Cell {\n  letter: string;\n  owner: null | 'Player 1' | 'Player 2';\n  captured: boolean;\n  pulse: boolean;\n}\n\nfunction createBoardWithOwnership(letters: string[][]): Cell[][] {\n  return letters.map(row => row.map(letter => ({ letter, owner: null, captured: false, pulse: false })));\n}\n// Figma UI update END\n\nfunction App() {\n  const [board, setBoard] = useState<Cell[][]>([]);\n  const [turn, setTurn] = useState<'Player 1' | 'Player 2'>('Player 1');\n  const [selected, setSelected] = useState<[number, number][]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [moves, setMoves] = useState<{ player: string, word: string, positions: [number, number][], score: number, capturePoints: number }[]>([]);\n  const [scores, setScores] = useState<{ [player: string]: number }>({ 'Player 1': 0, 'Player 2': 0 });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState<string | null>(null);\n  const [dictionary, setDictionary] = useState<Set<string> | null>(null);\n  const [passCount, setPassCount] = useState(0);\n  // Add modal state\n  const [showInstructions, setShowInstructions] = useState(false);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt')\n      .then(res => res.text())\n      .then(text => {\n        const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n        setDictionary(new Set(words));\n      });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => board[i]?.[j]?.letter || '').join('');\n\n  // Handle cell click\n  const handleCellClick = (i: number, j: number) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected: [number, number][];\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i: number, j: number, moves: { positions: [number, number][] }[]) => {\n    return board[i][j].owner !== null;\n  };\n\n  // --- Encirclement Logic Version 1 ---\n  // This is the preferred and tested encirclement logic as of [date].\n  // To roll back to this version, search for 'Encirclement Logic Version 1'.\n  // The logic allows capture even if there are unclaimed tiles adjacent, as long as those unclaimed tiles are also fully surrounded and cannot form a valid word.\n  // The previous logic is commented out below for easy rollback.\n  // --- END Encirclement Logic Version 1 ---\n  function findEncircledGroups(board: Cell[][], currentPlayer: 'Player 1' | 'Player 2', dictionary: Set<string>): [number, number][][] {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({ length: size }, () => Array(size).fill(false));\n    const groups: [number, number][][] = [];\n    function isEdge(i: number, j: number) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI: number, startJ: number) {\n      const queue: [number, number][] = [[startI, startJ]];\n      const group: [number, number][] = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set<string>();\n      while (queue.length) {\n        const [i, j] = queue.shift()!;\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [\n          [-1, 0], [1, 0], [0, -1], [0, 1]\n        ]) {\n          const ni = i + di, nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return { group, edgeTouches };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const { group, edgeTouches } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // --- BEGIN: Old logic for easy rollback ---\n          /*\n          // New encirclement logic: expand group to include any unclaimed tiles fully enclosed by the boundary. Only capture if no valid word can be formed from the unclaimed tiles inside the boundary.\n          // 1. Find all unclaimed tiles orthogonally connected to the group that are also fully enclosed (do not touch more than one edge or connect to outside)\n          const groupSet = new Set(group.map(([x, y]) => `${x},${y}`));\n          const enclosedUnclaimed: [number, number][] = [];\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (board[ni][nj].owner === null && !groupSet.has(`${ni},${nj}`)) {\n                // Check if this unclaimed tile is fully enclosed (BFS to see if it can reach the edge without passing through currentPlayer's tiles)\n                const queue: [number, number][] = [[ni, nj]];\n                const visitedUnclaimed = new Set([`${ni},${nj}`]);\n                let touchesEdge = false;\n                let escapes = false;\n                while (queue.length) {\n                  const [ui, uj] = queue.shift()!;\n                  if (isEdge(ui, uj)) touchesEdge = true;\n                  for (const [udi, udj] of [\n                    [-1, 0], [1, 0], [0, -1], [0, 1]\n                  ]) {\n                    const vi = ui + udi, vj = uj + udj;\n                    if (vi < 0 || vj < 0 || vi >= size || vj >= size) continue;\n                    if (board[vi][vj].owner === currentPlayer) continue; // blocked by current player's tile\n                    if (!visitedUnclaimed.has(`${vi},${vj}`) && board[vi][vj].owner === null) {\n                      visitedUnclaimed.add(`${vi},${vj}`);\n                      queue.push([vi, vj]);\n                    }\n                  }\n                }\n                if (!touchesEdge) {\n                  enclosedUnclaimed.push([ni, nj]);\n                  groupSet.add(`${ni},${nj}`);\n                }\n              }\n            }\n          }\n          // Now, group + enclosedUnclaimed is the full encircled area\n          const allEncircled = [...group, ...enclosedUnclaimed];\n          const groupLetters = allEncircled.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allEncircled);\n            groups.push(group);\n          }\n          */\n          // --- END: Old logic for easy rollback ---\n          // New logic: flood fill from group and all orthogonally adjacent unclaimed tiles. If the fill cannot reach the board edge without crossing currentPlayer's tiles, and no valid word can be formed from the unclaimed tiles, capture the group.\n          const floodVisited = Array.from({ length: size }, () => Array(size).fill(false));\n          const queue: [number, number][] = [...group];\n          group.forEach(([x, y]) => { floodVisited[x][y] = true; });\n          // Add all orthogonally adjacent unclaimed tiles to the queue\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              if (!floodVisited[ni][nj] && board[ni][nj].owner === null) {\n                queue.push([ni, nj]);\n                floodVisited[ni][nj] = true;\n              }\n            }\n          }\n          let escapes = false;\n          let allFlood: [number, number][] = [];\n          while (queue.length) {\n            const [cx, cy] = queue.shift()!;\n            allFlood.push([cx, cy]);\n            if (isEdge(cx, cy)) escapes = true;\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const nx = cx + di, ny = cy + dj;\n              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;\n              if (floodVisited[nx][ny]) continue;\n              if (board[nx][ny].owner === currentPlayer) continue; // blocked by current player's tile\n              floodVisited[nx][ny] = true;\n              queue.push([nx, ny]);\n            }\n          }\n          if (escapes) {\n            console.log('Flood fill escapes to edge, not encircled');\n            continue;\n          }\n          // Only capture if no valid word can be formed from the unclaimed tiles in the flood area\n          const groupLetters = allFlood.filter(([x, y]) => board[x][y].owner === null).map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', allFlood);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({ ...cell })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions: [number, number][] = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({ ...cell, pulse: false }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, { player: turn, word, positions: [...selected], score, capturePoints: capturedCount }]);\n    setScores(s => ({ ...s, [turn]: s[turn] + score + capturedCount }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n      else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n      else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n    else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n    else setWinner('Draw');\n  };\n\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({ 'Player 1': 0, 'Player 2': 0 });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i: number, j: number, moves: { player: string, positions: [number, number][] }[]) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n\n  // Replace the instructionsMarkdown and ReactMarkdown usage with the .txt content in a <pre> tag\n  return (\n    <div className=\"App\">\n      <h1>Word Strategy Game (Local Two-Player)</h1>\n      <div><strong>Current Turn:</strong> {turn}</div>\n      {/* Figma UI update START: Score Panel */}\n      <div style={{ display: 'none' }}>\n        <div className=\"score-panel\" style={{ display: 'flex', gap: 40, alignItems: 'center' }}>\n          <span className=\"player1\">Player 1: {scores['Player 1']}</span>\n          <span className=\"player2\">Player 2: {scores['Player 2']}</span>\n        </div>\n      </div>\n      {/* Figma UI update END */}\n      {gameOver && (\n        <div style={{ background: '#eee', padding: 20, borderRadius: 8, margin: 20 }}>\n          <h2>Game Over</h2>\n          {winner === 'Draw' ? <div><strong>It's a draw!</strong></div> : <div><strong>{winner} wins!</strong></div>}\n          <button onClick={handleRestart}>Restart Game</button>\n        </div>\n      )}\n      {/* Column numbers (1-based, aligned above columns) */}\n      {/* Removed the flex div with the numbers at the top as requested */}\n      <div style={{ display: 'inline-block', marginTop: 20 }}>\n        {/* Board rows with row numbers (1-based, aligned left) */}\n        <div\n          style={{\n            display: 'grid',\n            gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n            marginTop: 20,\n            border: '3px solid #000',\n            width: (board.length + 1) * 30,\n            position: 'relative',\n          }}\n        >\n          {/* Column numbers (1-based) */}\n          {board[0] && board[0].map((_, j) => (\n            <div\n              key={j}\n              style={{\n                gridRow: 1,\n                gridColumn: j + 2,\n                width: 30,\n                height: 30,\n                textAlign: 'center',\n                fontWeight: 'bold',\n                color: '#888',\n                lineHeight: '30px',\n                background: '#fff',\n                zIndex: 1,\n              }}\n            >\n              {j + 1}\n            </div>\n          ))}\n          {/* Row numbers (1-based) and board cells */}\n          {board.map((row, i) => (\n            <React.Fragment key={i}>\n              {/* Row number */}\n              <div\n                style={{\n                  gridRow: i + 2,\n                  gridColumn: 1,\n                  width: 30,\n                  height: 30,\n                  textAlign: 'center',\n                  fontWeight: 'bold',\n                  color: '#888',\n                  lineHeight: '30px',\n                  background: '#fff',\n                  zIndex: 1,\n                }}\n              >\n                {i + 1}\n              </div>\n              {/* Board cells */}\n              {row.map((cell, j) => {\n                const isSelected = selected.some(([x, y]) => x === i && y === j);\n                const claimed = isCellClaimed(i, j, moves);\n                let cellClass = 'board-cell';\n                if (i === center[0] && j === center[1]) cellClass += ' center';\n                if (isSelected) cellClass += ' selected';\n                if (claimed) {\n                  const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n                  if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';\n                  else cellClass += ' claimed';\n                }\n                let pulse = '';\n                if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n                  pulse = ' pulse';\n                }\n                return (\n                  <div\n                    key={j}\n                    className={cellClass + pulse}\n                    style={{ width: 30, height: 30, gridRow: i + 2, gridColumn: j + 2 }}\n                    onClick={() => {\n                      if (!claimed) handleCellClick(i, j);\n                    }}\n                  >\n                    {cell.letter}\n                  </div>\n                );\n              })}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n      <div style={{ marginTop: 20 }}>\n        <strong>Selected Word:</strong> {selectedWord}\n      </div>\n      {/* Player Scores and Submit Button Layout */}\n      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: (board.length + 1) * 30, margin: '30px auto 0 auto' }}>\n        <div className=\"player-score-left\" style={{ textAlign: 'left', minWidth: 120 }}>\n          <div style={{ color: '#3399ff', fontWeight: 'bold', fontSize: 48, lineHeight: 1 }}>{scores['Player 1']}</div>\n          <div style={{ fontWeight: 'bold', fontSize: 18 }}>Player 1</div>\n        </div>\n        <div style={{ flex: 1, textAlign: 'center' }}>\n          <div style={{ fontWeight: 'bold', fontSize: 32, marginBottom: 10 }}>{selectedWord}</div>\n          <button\n            className=\"submit-word-btn\"\n            style={{\n              background: '#000',\n              color: '#fff',\n              border: 'none',\n              borderRadius: 999,\n              padding: '16px 48px',\n              fontWeight: 'bold',\n              fontSize: 20,\n              margin: '0 auto',\n              display: 'block',\n              boxShadow: '0 2px 8px rgba(0,0,0,0.08)',\n              cursor: 'pointer',\n              marginTop: 10\n            }}\n            onClick={handleSubmit}\n            disabled={selected.length === 0 || gameOver}\n          >\n            Submit Word\n          </button>\n        </div>\n        <div className=\"player-score-right\" style={{ textAlign: 'right', minWidth: 120 }}>\n          <div style={{ color: '#FFA600', fontWeight: 'bold', fontSize: 48, lineHeight: 1 }}>{scores['Player 2']}</div>\n          <div style={{ fontWeight: 'bold', fontSize: 18 }}>Player 2</div>\n        </div>\n      </div>\n      {/* Player Words List - Two Columns */}\n      <div style={{ display: 'flex', justifyContent: 'space-between', width: (board.length + 1) * 30, margin: '30px auto 0 auto' }}>\n        {/* Player 1 Words */}\n        <div style={{ textAlign: 'left', minWidth: 180 }}>\n          {moves.filter(m => m.player === 'Player 1').map((move, idx, arr) => (\n            <div key={idx} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontWeight: idx === arr.length - 1 ? 'bold' : 'normal', borderRadius: 6, padding: 0, marginBottom: 2, textAlign: 'left' }}>\n              <span>{move.word}</span>\n              <span>\n                {move.score}\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#FFA600', marginLeft: 4 }}>+ {move.capturePoints}</span>\n                )}\n              </span>\n            </div>\n          ))}\n          <div style={{ borderTop: '2px solid #222', margin: '8px 0' }}></div>\n          <div style={{ fontWeight: 'bold', marginTop: 4 }}>TOTAL {scores['Player 1']}</div>\n        </div>\n        {/* Player 2 Words */}\n        <div style={{ textAlign: 'right', minWidth: 180 }}>\n          {moves.filter(m => m.player === 'Player 2').map((move, idx, arr) => (\n            <div key={idx} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontWeight: idx === arr.length - 1 ? 'bold' : 'normal', borderRadius: 6, padding: 0, marginBottom: 2, textAlign: 'left' }}>\n              <span>{move.word}</span>\n              <span>\n                {move.score}\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#3399ff', marginLeft: 4 }}>+ {move.capturePoints}</span>\n                )}\n              </span>\n            </div>\n          ))}\n          <div style={{ borderTop: '2px solid #222', margin: '8px 0' }}></div>\n          <div style={{ fontWeight: 'bold', marginTop: 4 }}>TOTAL {scores['Player 2']}</div>\n        </div>\n      </div>\n      <button onClick={handlePass} disabled={gameOver} style={{ marginLeft: 10 }}>Pass Turn</button>\n      <button onClick={handleEndGame} style={{ marginLeft: 10 }}>End Game</button>\n      {error && <div style={{ color: 'red', marginTop: 10 }}>{error}</div>}\n      {/* Figma UI update START: Move History */}\n      <div className=\"move-history-container\" style={{ display: 'none' }}>\n        {/* Player 1 Move History (Left) */}\n        <div className=\"move-history-player1\" style={{ textAlign: 'left', minWidth: 180 }}>\n          <h2 style={{ color: '#3399ff' }}>Player 1</h2>\n          <div style={{ fontWeight: 'bold', marginBottom: 8 }}>Points: {scores['Player 1']}</div>\n          <ol>\n            {moves.filter(m => m.player === 'Player 1').map((move, idx) => (\n              <li key={idx} className=\"player1\">\n                {move.word} ({move.score} pts)\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#FFA600', marginLeft: 6 }}>+{move.capturePoints} capture</span>\n                )}\n              </li>\n            ))}\n          </ol>\n        </div>\n        {/* Player 2 Move History (Right) */}\n        <div className=\"move-history-player2\" style={{ textAlign: 'right', minWidth: 180 }}>\n          <h2 style={{ color: '#FFA600' }}>Player 2</h2>\n          <div style={{ fontWeight: 'bold', marginBottom: 8 }}>Points: {scores['Player 2']}</div>\n          <ol>\n            {moves.filter(m => m.player === 'Player 2').map((move, idx) => (\n              <li key={idx} className=\"player2\">\n                {move.word} ({move.score} pts)\n                {move.capturePoints > 0 && (\n                  <span style={{ color: '#3399ff', marginLeft: 6 }}>+{move.capturePoints} capture</span>\n                )}\n              </li>\n            ))}\n          </ol>\n        </div>\n      </div>\n      {/* Figma UI update END */}\n      {/* Add Instructions Modal and Button at the bottom */}\n      <div style={{ marginTop: 40, textAlign: 'center' }}>\n        <button onClick={() => setShowInstructions(true)} style={{ padding: '12px 32px', borderRadius: 24, background: '#222', color: '#fff', fontWeight: 'bold', fontSize: 18, border: 'none', cursor: 'pointer' }}>\n          Show Instructions\n        </button>\n      </div>\n      {showInstructions && (\n        <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0,0,0,0.5)', zIndex: 1000, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\n          <div style={{ background: '#fff', borderRadius: 12, padding: 32, maxWidth: 600, width: '90%', boxShadow: '0 4px 24px rgba(0,0,0,0.2)', position: 'relative' }}>\n            <button onClick={() => setShowInstructions(false)} style={{ position: 'absolute', top: 16, right: 16, background: 'none', border: 'none', fontSize: 24, cursor: 'pointer' }}>&times;</button>\n            <h2>Game Instructions</h2>\n            <div style={{ maxHeight: 400, overflowY: 'auto', textAlign: 'left', fontFamily: 'inherit', fontSize: 16 }}>\n              <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', margin: 0 }}>\n{`[Working Title]: A Word Strategy Game of Territory and Capture\nOverview\nA two-player game combining the strategic depth of Go with the linguistic creativity of Scrabble. Players take turns forming words on a 19x19 board to earn points and capture territory.\nObjective\nScore the highest number of points by:\n- Forming valid words on the board (word score)\n- Capturing your opponent’s tiles through strategic encirclement (tile capture)\nComponents\n- 19x19 game board populated with randomly generated letters per game\n- Two sets of tiles (Black and White), one for each player\n- A valid dictionary for word verification (e.g., Scrabble dictionary)\n- Game software to validate moves and track scores\nSetup\n- Each game begins with a freshly generated 19x19 board of letters.\n- The distribution is based on common letter frequency, and may include pre-baked eight-letter words for bonus opportunities.\n- Players are assigned either White or Black tiles.\n- The central square of the board must be part of the first move.\nGameplay\nStarting the Game:\n- Player 1 begins by forming a word using contiguous tiles (touching on sides or corners).\n- The word must be at least two letters long and must include the center square.\n- Words can be placed in any direction (horizontally, vertically, or diagonally).\n- Player 2 then makes their move, and players alternate turns.\n\nForming Words:\n- On a turn, a player must place a new word on the board using available letters.\n- Words must be valid as determined by the shared dictionary. The system will automatically verify validity.\n- Words do not need to connect to existing words unless used to break an encirclement.\n- Multiple words may exist independently on the board.\nScoring\nWord Score\nPoints are awarded based on the length of each valid word:\nWord Length\nPoints\n2 letters\n2 pts\n3 letters\n3 pts\n4 letters\n4 pts\n5 letters\n6 pts\n6 letters\n8 pts\n7 letters\n11 pts\n8 letters\n14 pts\n9 letters\n19 pts\n10 letters\n24 pts\n11+ letters\n30 pts\nCapture Score\n- When a player successfully encircles a group of their opponent’s tiles, those tiles are captured.\n- Each captured tile adds 1 point to the capturing player’s score.\n- A tile can only be captured once; it cannot be part of multiple encirclements.\nEncirclement Rules\nA group of tiles is considered encircled and captured if:\n1. The opponent’s tiles are completely surrounded by the current player’s tiles.\n2. The surrounded player cannot make a legitimate contiguous move (side-touching only; corner-touching doesn’t count).\n3. There are no valid words possible inside the encircled area.\n4. Encirclement is also valid if:\n   - The opponent is blocked against a single edge of the board and surrounded on all other sides.\n   - However, if they touch more than one edge, it's not considered encircled.\n\nThe software will automatically detect and indicate when an encirclement occurs, and display how many tiles have been captured.\nEnd of Game\nThe game ends when:\n- No valid moves remain for either player, or\n- A player resigns\nWinning\nThe player with the highest combined score wins. The total score is:\n- Word Score (sum of all valid words created)\n- Capture Score (number of opponent tiles captured)\nLive Scoring\nAfter each move, the current scores (word + capture) are displayed so both players can monitor progress.\n`}\n              </pre>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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MAAM,EAAE;YAAE,CAAE;YAAAZ,QAAA,EACxF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UAAC;YAAAC,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OACkB;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACH,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CACN;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEV;AAAClG,EAAA,CApqBQD,GAAG;AAAAuJ,EAAA,GAAHvJ,GAAG;AAsqBZ,eAAeA,GAAG;AAAC,IAAAuJ,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}