{"ast":null,"code":"var _jsxFileName = \"/Users/ben/StratGO/frontend/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\n\n// Letter frequencies for board generation\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst letterFrequencies = [{\n  letter: 'E',\n  freq: 12.7\n}, {\n  letter: 'T',\n  freq: 9.1\n}, {\n  letter: 'A',\n  freq: 8.2\n}, {\n  letter: 'O',\n  freq: 7.5\n}, {\n  letter: 'I',\n  freq: 7.0\n}, {\n  letter: 'N',\n  freq: 6.7\n}, {\n  letter: 'S',\n  freq: 6.3\n}, {\n  letter: 'H',\n  freq: 6.1\n}, {\n  letter: 'R',\n  freq: 6.0\n}, {\n  letter: 'D',\n  freq: 4.3\n}, {\n  letter: 'L',\n  freq: 4.0\n}, {\n  letter: 'C',\n  freq: 2.8\n}, {\n  letter: 'U',\n  freq: 2.8\n}, {\n  letter: 'M',\n  freq: 2.4\n}, {\n  letter: 'W',\n  freq: 2.4\n}, {\n  letter: 'F',\n  freq: 2.2\n}, {\n  letter: 'G',\n  freq: 2.0\n}, {\n  letter: 'Y',\n  freq: 2.0\n}, {\n  letter: 'P',\n  freq: 1.9\n}, {\n  letter: 'B',\n  freq: 1.5\n}, {\n  letter: 'V',\n  freq: 1.0\n}, {\n  letter: 'K',\n  freq: 0.8\n}, {\n  letter: 'J',\n  freq: 0.15\n}, {\n  letter: 'X',\n  freq: 0.15\n}, {\n  letter: 'Q',\n  freq: 0.10\n}, {\n  letter: 'Z',\n  freq: 0.07\n}];\nconst weightedLetters = [];\nletterFrequencies.forEach(({\n  letter,\n  freq\n}) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({\n    length: size\n  }, (_, i) => Array.from({\n    length: size\n  }, (_, j) => getRandomLetter()));\n}\nconst scoreTable = {\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 6,\n  6: 8,\n  7: 11,\n  8: 14,\n  9: 19,\n  10: 24\n};\nfunction getScore(word) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\nfunction areAdjacent(a, b) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected) {\n  if (selected.length <= 1) return true;\n  const visited = new Set();\n  function dfs(cell) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\n\nfunction createBoardWithOwnership(letters) {\n  return letters.map(row => row.map(letter => ({\n    letter,\n    owner: null,\n    captured: false,\n    pulse: false\n  })));\n}\n// Figma UI update END\n\nfunction App() {\n  _s();\n  const [board, setBoard] = useState([]);\n  const [turn, setTurn] = useState('Player 1');\n  const [selected, setSelected] = useState([]);\n  const [error, setError] = useState(null);\n  const [moves, setMoves] = useState([]);\n  const [scores, setScores] = useState({\n    'Player 1': 0,\n    'Player 2': 0\n  });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [dictionary, setDictionary] = useState(null);\n  const [passCount, setPassCount] = useState(0);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt').then(res => res.text()).then(text => {\n      const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n      setDictionary(new Set(words));\n    });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => {\n    var _board$i, _board$i$j;\n    return ((_board$i = board[i]) === null || _board$i === void 0 ? void 0 : (_board$i$j = _board$i[j]) === null || _board$i$j === void 0 ? void 0 : _board$i$j.letter) || '';\n  }).join('');\n\n  // Handle cell click\n  const handleCellClick = (i, j) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected;\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i, j, moves) => {\n    return board[i][j].owner !== null;\n  };\n\n  // Encirclement logic\n  function findEncircledGroups(board, currentPlayer, dictionary) {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({\n      length: size\n    }, () => Array(size).fill(false));\n    const groups = [];\n    function isEdge(i, j) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI, startJ) {\n      const queue = [[startI, startJ]];\n      const group = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set();\n      while (queue.length) {\n        const [i, j] = queue.shift();\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {\n          const ni = i + di,\n            nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return {\n        group,\n        edgeTouches\n      };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const {\n            group,\n            edgeTouches\n          } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // Encirclement now only requires edge enclosure and no valid word in unclaimed tiles (per clarified rules, see screenshot example). To roll back, uncomment the block above.\n          const unclaimedTiles = group.filter(([x, y]) => board[x][y].owner === null);\n          const groupLetters = unclaimedTiles.map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', group);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({\n      ...cell\n    })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({\n        ...cell,\n        pulse: false\n      }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, {\n      player: turn,\n      word,\n      positions: [...selected],\n      score,\n      capturePoints: capturedCount\n    }]);\n    setScores(s => ({\n      ...s,\n      [turn]: s[turn] + score + capturedCount\n    }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');else setWinner('Draw');\n  };\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({\n      'Player 1': 0,\n      'Player 2': 0\n    });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i, j, moves) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Word Strategy Game (Local Two-Player)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 327,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Current Turn:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 328,\n        columnNumber: 12\n      }, this), \" \", turn]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 328,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"score-panel\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"player1\",\n        children: [\"Player 1: \", scores['Player 1']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 331,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"player2\",\n        children: [\"Player 2: \", scores['Player 2']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 332,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 7\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        background: '#eee',\n        padding: 20,\n        borderRadius: 8,\n        margin: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Game Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 337,\n        columnNumber: 11\n      }, this), winner === 'Draw' ? /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"It's a draw!\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 338,\n          columnNumber: 37\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 32\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: [winner, \" wins!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 338,\n          columnNumber: 80\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 75\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleRestart,\n        children: \"Restart Game\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 336,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'inline-block',\n        marginTop: 20\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'grid',\n          gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n          marginTop: 20,\n          border: '2px solid #333',\n          width: (board.length + 1) * 30,\n          position: 'relative'\n        },\n        children: [board[0] && board[0].map((_, j) => /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            gridRow: 1,\n            gridColumn: j + 2,\n            width: 30,\n            height: 30,\n            textAlign: 'center',\n            fontWeight: 'bold',\n            color: '#888',\n            lineHeight: '30px',\n            background: '#fff',\n            zIndex: 1\n          },\n          children: j + 1\n        }, j, false, {\n          fileName: _jsxFileName,\n          lineNumber: 358,\n          columnNumber: 13\n        }, this)), board.map((row, i) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              gridRow: i + 2,\n              gridColumn: 1,\n              width: 30,\n              height: 30,\n              textAlign: 'center',\n              fontWeight: 'bold',\n              color: '#888',\n              lineHeight: '30px',\n              background: '#fff',\n              zIndex: 1\n            },\n            children: i + 1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 380,\n            columnNumber: 15\n          }, this), row.map((cell, j) => {\n            const isSelected = selected.some(([x, y]) => x === i && y === j);\n            const claimed = isCellClaimed(i, j, moves);\n            let cellClass = 'board-cell';\n            if (i === center[0] && j === center[1]) cellClass += ' center';\n            if (isSelected) cellClass += ' selected';\n            if (claimed) {\n              const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n              if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';else cellClass += ' claimed';\n            }\n            let pulse = '';\n            if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n              pulse = ' pulse';\n            }\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: cellClass + pulse,\n              style: {\n                width: 30,\n                height: 30,\n                gridRow: i + 2,\n                gridColumn: j + 2\n              },\n              onClick: () => {\n                if (!claimed) handleCellClick(i, j);\n              },\n              children: cell.letter\n            }, j, false, {\n              fileName: _jsxFileName,\n              lineNumber: 413,\n              columnNumber: 19\n            }, this);\n          })]\n        }, i, true, {\n          fileName: _jsxFileName,\n          lineNumber: 378,\n          columnNumber: 13\n        }, this))]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 344,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 20\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"Selected Word:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 430,\n        columnNumber: 9\n      }, this), \" \", selectedWord]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 429,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleSubmit,\n      disabled: selected.length === 0 || gameOver,\n      style: {\n        marginTop: 10\n      },\n      children: \"Submit Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 432,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handlePass,\n      disabled: gameOver,\n      style: {\n        marginLeft: 10\n      },\n      children: \"Pass Turn\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 435,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleEndGame,\n      style: {\n        marginLeft: 10\n      },\n      children: \"End Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 436,\n      columnNumber: 7\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        color: 'red',\n        marginTop: 10\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"move-history\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Move History\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 440,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n        children: moves.map((move, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n          className: move.player === 'Player 1' ? 'player1' : 'player2',\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: [move.player, \":\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 444,\n            columnNumber: 15\n          }, this), \" \", move.word, \" (\", move.score, \" pts)\", move.capturePoints > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n            style: {\n              color: '#FFA600',\n              marginLeft: 6\n            },\n            children: [\"+\", move.capturePoints, \" capture\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 446,\n            columnNumber: 17\n          }, this)]\n        }, idx, true, {\n          fileName: _jsxFileName,\n          lineNumber: 443,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 441,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 439,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 326,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"BcbGZaxt1PrcioqWyxXRMd4Q6ik=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","jsxDEV","_jsxDEV","letterFrequencies","letter","freq","weightedLetters","forEach","i","Math","round","push","getRandomLetter","floor","random","length","generateBoard","size","Array","from","_","j","scoreTable","getScore","word","areAdjacent","a","b","x1","y1","x2","y2","abs","isContiguous","selected","visited","Set","dfs","cell","add","join","next","has","center","createBoardWithOwnership","letters","map","row","owner","captured","pulse","App","_s","board","setBoard","turn","setTurn","setSelected","error","setError","moves","setMoves","scores","setScores","gameOver","setGameOver","winner","setWinner","dictionary","setDictionary","passCount","setPassCount","fetch","then","res","text","words","split","w","trim","toUpperCase","selectedWord","_board$i","_board$i$j","handleCellClick","idx","findIndex","x","y","newSelected","slice","concat","isCellClaimed","findEncircledGroups","currentPlayer","opponent","fill","groups","isEdge","bfs","startI","startJ","queue","group","edgeTouches","edgeSet","shift","di","dj","ni","nj","console","log","unclaimedTiles","filter","groupLetters","hasValidWord","len","start","handleSubmit","some","newBoard","encircledGroups","capturedCount","capturedPositions","setTimeout","score","player","positions","capturePoints","s","handlePass","c","handleEndGame","handleRestart","getCellColor","k","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","background","padding","borderRadius","margin","onClick","display","marginTop","gridTemplateColumns","border","width","position","gridRow","gridColumn","height","textAlign","fontWeight","color","lineHeight","zIndex","Fragment","isSelected","claimed","cellClass","lastMove","reverse","find","m","disabled","marginLeft","move","_c","$RefreshReg$"],"sources":["/Users/ben/StratGO/frontend/src/App.tsx"],"sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport './AppFigma.css'; // Figma UI update START\n\n// Letter frequencies for board generation\nconst letterFrequencies = [\n  { letter: 'E', freq: 12.7 }, { letter: 'T', freq: 9.1 }, { letter: 'A', freq: 8.2 },\n  { letter: 'O', freq: 7.5 }, { letter: 'I', freq: 7.0 }, { letter: 'N', freq: 6.7 },\n  { letter: 'S', freq: 6.3 }, { letter: 'H', freq: 6.1 }, { letter: 'R', freq: 6.0 },\n  { letter: 'D', freq: 4.3 }, { letter: 'L', freq: 4.0 }, { letter: 'C', freq: 2.8 },\n  { letter: 'U', freq: 2.8 }, { letter: 'M', freq: 2.4 }, { letter: 'W', freq: 2.4 },\n  { letter: 'F', freq: 2.2 }, { letter: 'G', freq: 2.0 }, { letter: 'Y', freq: 2.0 },\n  { letter: 'P', freq: 1.9 }, { letter: 'B', freq: 1.5 }, { letter: 'V', freq: 1.0 },\n  { letter: 'K', freq: 0.8 }, { letter: 'J', freq: 0.15 }, { letter: 'X', freq: 0.15 },\n  { letter: 'Q', freq: 0.10 }, { letter: 'Z', freq: 0.07 },\n];\nconst weightedLetters: string[] = [];\nletterFrequencies.forEach(({ letter, freq }) => {\n  for (let i = 0; i < Math.round(freq * 10); i++) weightedLetters.push(letter);\n});\nfunction getRandomLetter() {\n  return weightedLetters[Math.floor(Math.random() * weightedLetters.length)];\n}\nfunction generateBoard(size = 19) {\n  return Array.from({ length: size }, (_, i) =>\n    Array.from({ length: size }, (_, j) => getRandomLetter())\n  );\n}\n\nconst scoreTable: { [len: number]: number } = {\n  2: 2, 3: 3, 4: 4, 5: 6, 6: 8, 7: 11, 8: 14, 9: 19, 10: 24\n};\nfunction getScore(word: string) {\n  if (word.length >= 11) return 30;\n  return scoreTable[word.length] || 0;\n}\n\nfunction areAdjacent(a: [number, number], b: [number, number]) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);\n}\nfunction isContiguous(selected: [number, number][]) {\n  if (selected.length <= 1) return true;\n  const visited = new Set<string>();\n  function dfs(cell: [number, number]) {\n    visited.add(cell.join(','));\n    for (const next of selected) {\n      if (!visited.has(next.join(',')) && areAdjacent(cell, next)) dfs(next);\n    }\n  }\n  dfs(selected[0]);\n  return visited.size === selected.length;\n}\n\nconst center = [9, 9];\n\n// Figma UI update START\n// Cell type for ownership and capture\ninterface Cell {\n  letter: string;\n  owner: null | 'Player 1' | 'Player 2';\n  captured: boolean;\n  pulse: boolean;\n}\n\nfunction createBoardWithOwnership(letters: string[][]): Cell[][] {\n  return letters.map(row => row.map(letter => ({ letter, owner: null, captured: false, pulse: false })));\n}\n// Figma UI update END\n\nfunction App() {\n  const [board, setBoard] = useState<Cell[][]>([]);\n  const [turn, setTurn] = useState<'Player 1' | 'Player 2'>('Player 1');\n  const [selected, setSelected] = useState<[number, number][]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [moves, setMoves] = useState<{ player: string, word: string, positions: [number, number][], score: number, capturePoints: number }[]>([]);\n  const [scores, setScores] = useState<{ [player: string]: number }>({ 'Player 1': 0, 'Player 2': 0 });\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState<string | null>(null);\n  const [dictionary, setDictionary] = useState<Set<string> | null>(null);\n  const [passCount, setPassCount] = useState(0);\n\n  // Replace board generation\n  useEffect(() => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    // Load dictionary\n    fetch('/words_alpha.txt')\n      .then(res => res.text())\n      .then(text => {\n        const words = text.split(/\\r?\\n/).map(w => w.trim().toUpperCase());\n        setDictionary(new Set(words));\n      });\n  }, []);\n\n  // Helper: get word from selected cells\n  const selectedWord = selected.map(([i, j]) => board[i]?.[j]?.letter || '').join('');\n\n  // Handle cell click\n  const handleCellClick = (i: number, j: number) => {\n    if (gameOver) return;\n    const idx = selected.findIndex(([x, y]) => x === i && y === j);\n    let newSelected: [number, number][];\n    if (idx !== -1) {\n      newSelected = selected.slice(0, idx).concat(selected.slice(idx + 1));\n    } else {\n      newSelected = [...selected, [i, j]];\n    }\n    setSelected(newSelected);\n    setError(null);\n  };\n\n  // Helper: check if cell is claimed\n  const isCellClaimed = (i: number, j: number, moves: { positions: [number, number][] }[]) => {\n    return board[i][j].owner !== null;\n  };\n\n  // Encirclement logic\n  function findEncircledGroups(board: Cell[][], currentPlayer: 'Player 1' | 'Player 2', dictionary: Set<string>): [number, number][][] {\n    const size = board.length;\n    const opponent = currentPlayer === 'Player 1' ? 'Player 2' : 'Player 1';\n    const visited = Array.from({ length: size }, () => Array(size).fill(false));\n    const groups: [number, number][][] = [];\n    function isEdge(i: number, j: number) {\n      return i === 0 || j === 0 || i === size - 1 || j === size - 1;\n    }\n    function bfs(startI: number, startJ: number) {\n      const queue: [number, number][] = [[startI, startJ]];\n      const group: [number, number][] = [];\n      let edgeTouches = 0;\n      visited[startI][startJ] = true;\n      const edgeSet = new Set<string>();\n      while (queue.length) {\n        const [i, j] = queue.shift()!;\n        group.push([i, j]);\n        if (isEdge(i, j)) edgeSet.add(`${i},${j}`);\n        for (const [di, dj] of [\n          [-1, 0], [1, 0], [0, -1], [0, 1]\n        ]) {\n          const ni = i + di, nj = j + dj;\n          if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n          const cell = board[ni][nj];\n          if (!visited[ni][nj] && cell.owner === opponent && !cell.captured) {\n            visited[ni][nj] = true;\n            queue.push([ni, nj]);\n          }\n        }\n      }\n      edgeTouches = Array.from(edgeSet).length;\n      return { group, edgeTouches };\n    }\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        if (!visited[i][j] && board[i][j].owner === opponent && !board[i][j].captured) {\n          const { group, edgeTouches } = bfs(i, j);\n          console.log('Checking group:', group, 'edgeTouches:', edgeTouches);\n          if (edgeTouches > 1) {\n            console.log('Group touches more than one edge, skipping');\n            continue;\n          }\n          // --- BEGIN: Old adjacency-based surrounded check (commented for rollback) ---\n          /*\n          let surrounded = true;\n          for (const [x, y] of group) {\n            for (const [di, dj] of [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ]) {\n              const ni = x + di, nj = y + dj;\n              if (ni < 0 || nj < 0 || ni >= size || nj >= size) continue;\n              const cell = board[ni][nj];\n              if (cell.owner !== currentPlayer && cell.owner !== opponent) surrounded = false;\n            }\n          }\n          if (!surrounded) {\n            console.log('Group not fully surrounded, skipping');\n            continue;\n          }\n          */\n          // --- END: Old adjacency-based surrounded check ---\n          // Encirclement now only requires edge enclosure and no valid word in unclaimed tiles (per clarified rules, see screenshot example). To roll back, uncomment the block above.\n          const unclaimedTiles = group.filter(([x, y]) => board[x][y].owner === null);\n          const groupLetters = unclaimedTiles.map(([x, y]) => board[x][y].letter);\n          let hasValidWord = false;\n          for (let len = 2; len <= groupLetters.length; len++) {\n            for (let start = 0; start <= groupLetters.length - len; start++) {\n              const word = groupLetters.slice(start, start + len).join('').toUpperCase();\n              if (dictionary.has(word)) {\n                hasValidWord = true;\n                break;\n              }\n            }\n            if (hasValidWord) break;\n          }\n          if (hasValidWord) {\n            console.log('Group has valid word, skipping:', groupLetters);\n          }\n          if (!hasValidWord) {\n            console.log('Group is encircled and has no valid word:', group);\n            groups.push(group);\n          }\n        }\n      }\n    }\n    console.log('Returning encircled groups:', groups);\n    return groups;\n  }\n\n  // Handle submit (with encirclement)\n  const handleSubmit = () => {\n    if (gameOver) return;\n    if (selected.length < 2) {\n      setError('Word must be at least 2 letters.');\n      return;\n    }\n    if (!isContiguous(selected)) {\n      setError('Selected letters must be contiguous.');\n      return;\n    }\n    if (moves.length === 0 && !selected.some(([i, j]) => i === center[0] && j === center[1])) {\n      setError('First word must include the center square.');\n      return;\n    }\n    if (!dictionary) {\n      setError('Dictionary not loaded yet.');\n      return;\n    }\n    const word = selectedWord.toUpperCase();\n    if (!dictionary.has(word)) {\n      setError('Word not in dictionary.');\n      return;\n    }\n    // --- Refactor: perform encirclement/capture logic before setBoard ---\n    // 1. Create a copy of the board and apply the current move\n    const newBoard = board.map(row => row.map(cell => ({ ...cell })));\n    selected.forEach(([i, j]) => {\n      newBoard[i][j].owner = turn;\n      newBoard[i][j].captured = false;\n      newBoard[i][j].pulse = true;\n    });\n    console.log('Board after claiming:', newBoard.map(row => row.map(cell => cell.owner)));\n    // 2. Find encircled groups and apply captures\n    const encircledGroups = findEncircledGroups(newBoard, turn, dictionary);\n    console.log('Encircled groups:', encircledGroups);\n    let capturedCount = 0;\n    let capturedPositions: [number, number][] = [];\n    encircledGroups.forEach(group => {\n      group.forEach(([x, y]) => {\n        newBoard[x][y].captured = true;\n        newBoard[x][y].pulse = true; // pulse animation\n        newBoard[x][y].owner = turn; // transfer ownership\n        capturedCount++;\n        capturedPositions.push([x, y]);\n      });\n    });\n    console.log('Captured count:', capturedCount);\n    setBoard(newBoard);\n    setTimeout(() => {\n      setBoard(b => b.map(row => row.map(cell => ({ ...cell, pulse: false }))));\n    }, 700);\n    const score = getScore(word);\n    setMoves([...moves, { player: turn, word, positions: [...selected], score, capturePoints: capturedCount }]);\n    setScores(s => ({ ...s, [turn]: s[turn] + score + capturedCount }));\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    if (capturedCount > 0) {\n      setError(`${capturedCount} tile(s) captured!`);\n    } else {\n      setError(null);\n    }\n    setPassCount(0); // reset pass count on valid move\n  };\n\n  const handlePass = () => {\n    if (gameOver) return;\n    setTurn(turn === 'Player 1' ? 'Player 2' : 'Player 1');\n    setSelected([]);\n    setError(null);\n    setPassCount(c => c + 1);\n  };\n\n  // End game logic (simple: after 30 moves or manual end)\n  useEffect(() => {\n    if (moves.length >= 30 || passCount >= 2) {\n      setGameOver(true);\n      if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n      else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n      else setWinner('Draw');\n    }\n  }, [moves, scores, passCount]);\n\n  const handleEndGame = () => {\n    setGameOver(true);\n    if (scores['Player 1'] > scores['Player 2']) setWinner('Player 1');\n    else if (scores['Player 2'] > scores['Player 1']) setWinner('Player 2');\n    else setWinner('Draw');\n  };\n\n  const handleRestart = () => {\n    const letters = generateBoard();\n    setBoard(createBoardWithOwnership(letters));\n    setTurn('Player 1');\n    setSelected([]);\n    setError(null);\n    setMoves([]);\n    setScores({ 'Player 1': 0, 'Player 2': 0 });\n    setGameOver(false);\n    setWinner(null);\n    setPassCount(0);\n  };\n\n  // Helper to get cell color based on moves\n  function getCellColor(i: number, j: number, moves: { player: string, positions: [number, number][] }[]) {\n    // Find the most recent move that includes this cell\n    for (let k = moves.length - 1; k >= 0; k--) {\n      if (moves[k].positions.some(([x, y]) => x === i && y === j)) {\n        return moves[k].player === 'Player 1' ? '#ffcccc' : '#cce0ff'; // red for P1, blue for P2\n      }\n    }\n    // Center square highlight\n    if (i === center[0] && j === center[1]) return '#ffe680';\n    return '#fff';\n  }\n\n  return (\n    <div className=\"App\">\n      <h1>Word Strategy Game (Local Two-Player)</h1>\n      <div><strong>Current Turn:</strong> {turn}</div>\n      {/* Figma UI update START: Score Panel */}\n      <div className=\"score-panel\">\n        <span className=\"player1\">Player 1: {scores['Player 1']}</span>\n        <span className=\"player2\">Player 2: {scores['Player 2']}</span>\n      </div>\n      {/* Figma UI update END */}\n      {gameOver && (\n        <div style={{ background: '#eee', padding: 20, borderRadius: 8, margin: 20 }}>\n          <h2>Game Over</h2>\n          {winner === 'Draw' ? <div><strong>It's a draw!</strong></div> : <div><strong>{winner} wins!</strong></div>}\n          <button onClick={handleRestart}>Restart Game</button>\n        </div>\n      )}\n      {/* Column numbers (1-based, aligned above columns) */}\n      {/* Removed the flex div with the numbers at the top as requested */}\n      <div style={{ display: 'inline-block', marginTop: 20 }}>\n        {/* Board rows with row numbers (1-based, aligned left) */}\n        <div\n          style={{\n            display: 'grid',\n            gridTemplateColumns: `repeat(${board.length + 1}, 30px)`,\n            marginTop: 20,\n            border: '2px solid #333',\n            width: (board.length + 1) * 30,\n            position: 'relative',\n          }}\n        >\n          {/* Column numbers (1-based) */}\n          {board[0] && board[0].map((_, j) => (\n            <div\n              key={j}\n              style={{\n                gridRow: 1,\n                gridColumn: j + 2,\n                width: 30,\n                height: 30,\n                textAlign: 'center',\n                fontWeight: 'bold',\n                color: '#888',\n                lineHeight: '30px',\n                background: '#fff',\n                zIndex: 1,\n              }}\n            >\n              {j + 1}\n            </div>\n          ))}\n          {/* Row numbers (1-based) and board cells */}\n          {board.map((row, i) => (\n            <React.Fragment key={i}>\n              {/* Row number */}\n              <div\n                style={{\n                  gridRow: i + 2,\n                  gridColumn: 1,\n                  width: 30,\n                  height: 30,\n                  textAlign: 'center',\n                  fontWeight: 'bold',\n                  color: '#888',\n                  lineHeight: '30px',\n                  background: '#fff',\n                  zIndex: 1,\n                }}\n              >\n                {i + 1}\n              </div>\n              {/* Board cells */}\n              {row.map((cell, j) => {\n                const isSelected = selected.some(([x, y]) => x === i && y === j);\n                const claimed = isCellClaimed(i, j, moves);\n                let cellClass = 'board-cell';\n                if (i === center[0] && j === center[1]) cellClass += ' center';\n                if (isSelected) cellClass += ' selected';\n                if (claimed) {\n                  const lastMove = moves.slice().reverse().find(m => m.positions.some(([x, y]) => x === i && y === j));\n                  if (lastMove) cellClass += lastMove.player === 'Player 1' ? ' player1 claimed' : ' player2 claimed';\n                  else cellClass += ' claimed';\n                }\n                let pulse = '';\n                if (moves.length > 0 && moves[moves.length - 1].positions.some(([x, y]) => x === i && y === j)) {\n                  pulse = ' pulse';\n                }\n                return (\n                  <div\n                    key={j}\n                    className={cellClass + pulse}\n                    style={{ width: 30, height: 30, gridRow: i + 2, gridColumn: j + 2 }}\n                    onClick={() => {\n                      if (!claimed) handleCellClick(i, j);\n                    }}\n                  >\n                    {cell.letter}\n                  </div>\n                );\n              })}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n      <div style={{ marginTop: 20 }}>\n        <strong>Selected Word:</strong> {selectedWord}\n      </div>\n      <button onClick={handleSubmit} disabled={selected.length === 0 || gameOver} style={{ marginTop: 10 }}>\n        Submit Word\n      </button>\n      <button onClick={handlePass} disabled={gameOver} style={{ marginLeft: 10 }}>Pass Turn</button>\n      <button onClick={handleEndGame} style={{ marginLeft: 10 }}>End Game</button>\n      {error && <div style={{ color: 'red', marginTop: 10 }}>{error}</div>}\n      {/* Figma UI update START: Move History */}\n      <div className=\"move-history\">\n        <h2>Move History</h2>\n        <ol>\n          {moves.map((move, idx) => (\n            <li key={idx} className={move.player === 'Player 1' ? 'player1' : 'player2'}>\n              <strong>{move.player}:</strong> {move.word} ({move.score} pts)\n              {move.capturePoints > 0 && (\n                <span style={{ color: '#FFA600', marginLeft: 6 }}>+{move.capturePoints} capture</span>\n              )}\n            </li>\n          ))}\n        </ol>\n      </div>\n      {/* Figma UI update END */}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}